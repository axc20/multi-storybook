import { Meta } from '@storybook/addon-docs';

<Meta title="typescript/generics" />

# Generics

[Generics](https://www.typescriptlang.org/docs/handbook/generics.html) provide a way to use Types as variables in other types.

```ts
// Example: wrap an input object in an array
// it's common to see Type referred to as T
function wrapInArray<Type>(input: Type): Type[] {
  return [input];
}

// generic inference
const stringArray = wrapInArray('hello generics');
const numberArray = wrapInArray(123);

// skip generic inference by adding type yourself
const stringArray2 = wrapInArray<string>('');

// wrapInArray allows any type to be used
// if you need to only allow a subset of types,
// can say the type has to extend a particular type
interface Drawable {
  draw: () => void;
}

// this function takes a set of objects which have
// a function for drawing to the screen
function renderToScreen<T extends Drawable>(input: Type[]) {
  input.forEach(i => i.draw());
}

// generics can look complicated when you have multiple variables
// Example: caching fn that allows different sets of input types
// and caches
interface CacheHost {
  save: (a: any) => void;
}

function addObjectToCache<T, Cache extends CacheHost>(obj: T, cache: Cache): Cache {
  cache.save(obj);
  return cache;
}

// same as above but with extra parameter
interface CacheHostGeneric<ContentType> {
  save: (a: ContentType) => void;
}

// now when the CacheHostGeneric is used,
// you need to tell it waht ContentType is
function addTypedObjectToCache<T, Cache extends CacheHostGeneric<T>>(obj: T, cache: Cache): Cache {
  cache.save(obj);
  return cache;
}

// this provides more safety, but there are trade-offs
// when providing APIs for others, generics offer a flexible
// way to let others use their own types with full code inference
```

Generic classes are a way to say that a particular type depends on another type.

```ts
// Example: a drawer which can hold any sort of object, but only one type
class Drawer<ClothingType> {
  contents: ClothingType[] = [];

  add(object: ClothingType) {
    this.contents.push(object);
  }

  remove() {
    return this.contents.pop();
  }
}

interface Sock {
  color: string;
}

interface TShirt {
  size: 's' | 'm' | 'l';
}

// drawer just for socks: pass type Sock
const sockDrawer = new Drawer<Sock>();
sockDrawer.add({ color: 'white' });
const mySock = sockDrawer.remove();

const tshirtDrawer = new Drawer<TShirt>();
tshirtDrawer.add({ size: 'm' });

// using union to create mixed drawer
const mixedDrawer = new Drawer<Sock | TShirt>();
```
